=All Ocsigen in one page=

This page describes the main concepts you need to master to become fully operational
with Ocsigen. Use it as your training plan or as a cheatcheet while programming.

Depending on your needs, you may not need to learn all this.
Ocsigen is very flexible and can be used both for very basic page generation
functions (see [[basicwebsite|this tutorial]]) or very complex
client-server Web apps and their mobile counterparts.

It is highly recommended to generate your first Ocsigen Start app to see
running examples of all these concepts while reading this page.

<<section class="docblock" |
<<header |==OCaml==>>

This programming guide assumes you know the //OCaml// language.
Many resources and books are available online.

>>

<<section class="docblock" |
<<header |==Lwt==>>

//Lwt// is a concurrent programming library for OCaml, initially written
by Jérôme Vouillon in 2001 for the
[[https://github.com/bcpierce00/unison|Unison]] file synchronizer.
It provides an alternative to the more usual preemptive threads approach
for programming concurrent applications, that avoids most problems of concurrent
data access and deadlocks.
It is used by Ocsigen Server and Eliom and has now become one of the
standard ways to implement concurrent applications in OCaml.
All your Web sites must be written in Lwt-compatible way!

<<div class="focused"|
===How it works===
Instead of calling blocking functions, like {{{Unix.sleep}}}
or {{{Unix.read}}}, that could block the entire program, replace them
by their cooperatives counterparts ({{{Lwt_unix.sleep}}},
{{{Lwt_unix.read}}}, etc.). Instead of taking time to execute,
they always return immediately a //promise// of the result,
of type {{{'a Lwt.t}}}. This type is abstract, and the only way
to use the result is to //bind// a function to the promise.
{{{Lwt.bind p f}}} means: "when promise {{{p}}} is completed, give its result
to function {{{f}}}".

Syntax {{{let%lwt x = p in e}}} is equivalent to {{{Lwt.bind p (fun x -> e)}}}
and makes it very natural to sequentialize computations without blocking the rest
of the program.
>>

Read more about Lwt in this [[lwt|short tutorial]] or in its [[wiki("lwt"):|user manual]].

>>

<<section class="docblock" |
<<header |==TyXML: typing HTML==>>

TyXML statically checks that your OCaml functions will never
generate wrong HTML. For example a program that could generate a paragraph
containing another paragraph will be rejected at compile time.

Example of use:
<<code language="ocaml"|
open Eliom_content.Html.D

(html
  (head (title (txt "")) [])
  (body [h1 ~a:[a_id "toto"; a_class ["blah"; "blih"]]
          [txt "Hallo!"]])))
>>

<<|From Eliom > 2.2
(you can also use <<a_api project="eliom" subproject="server"|val Eliom_tools.D.html> > to ease the creation of the {{{head}}} tag.)

(Eliom_tools.F.head
    ~title:"Hello"
    ~css:[["css";"style.css"]]
    ~js:[["libjs";"mylib.js"];
         ["libjs";"otherlib.js"]]
    ())
>>

<<code language="ocaml"|img
  ~alt:"blip"
  ~src:(make_uri
         (Eliom_service.static_dir ())
         ["dir" ; "image.jpg"])
  ()
>>

<<div class="focused"|
===How it works===

TyXML builds the page as an OCaml data-structure using a construction function
for each HTML tag. These functions take as parameters and return nodes
of type {{{'a elt}}} where {{{'a}}} is a polymorphic variant type added in the
module signature to constrain usage (phantom type).
>>

Eliom uses TyXML to create several kinds of nodes:

Module {{{Eliom_content.Html.F}}} will create a functional value representing
your nodes. On client side, calling {{{Eliom_content.Html.To_dom.of_element}}}
on these nodes will create a new DOM node.

Module {{{Eliom_content.Html.D}}} will automatically insert an id in the
attributes of the node, to label a precise instance of the node in the DOM.
On client side, calling {{{Eliom_content.Html.To_dom.of_element}}}
on these nodes will return the actual version of the nodes that are currently
in the page.

In a client server Eliom app,
you probably always want to use {{{Eliom_content.Html.D}}}
each time you want to bind events on
an element (and more generally if you need to inject this element using {{{~%}}}).


Read more about TyXML in this [[html|short tutorial]] or in its [[wiki("tyxml"):|user manual]].
>>

<<section class="docblock" |
<<header |==Eliom: Services==>>

Pages are generated by //services//.

To create a service, call <<a_api project="eliom"| val Eliom_service.create>>.
For example, the following code defines a service at URL {{{/foo}}},
that will use GET HTTP method, and take one parameter of type string,
named {{{myparam}}}, and one of type int, named {{{i}}}.
<<code language="ocaml" class="server"|
let myservice =
  Eliom_service.create
    ~path:(Eliom_service.Path ["foo"])
    ~meth:(Eliom_service.Get (Eliom_parameter.(string "myparam" ** int "i")))
    ()
>>

Then register an OCaml function as handler on this service:

<<code language="ocaml" class="server"|
let () =
  Eliom_registration.Html.register ~service:myservice
    (fun (myparam, i) () ->
      Lwt.return
         Eliom_content.Html.F.(html (head (title "")) (body [h1 [txt myparam]])))
>>

The handler takes as first parameter the GET page parameters, typed according to
the parameter specification given while creating the service.
The second parameter is for POST parameters (see below).

===Outputs===

Services can return a typed HTML page as in the example above, but also
any other kind of result. To choose the return type, user the register function
from the corresponding submodule of
<<a_api project="eliom" | module Eliom_registration >>:

<<div id="servicetable"|
|=@@class="row"@@<<a_api project="eliom" text="Html"| module Eliom_registration.Html >>|@@colspan="3"@@Typed HTML pages|
|=@@class="row"@@<<a_api project="eliom" text="App"| module Eliom_registration.ELIOM_APPL >>|@@colspan="3"@@Typed HTML pages belonging to an Eliom client/server application (functor). Eliom will automatically add the client-side program as a JS file, and all the data needed (values of all injections, etc.)|
|=@@class="row"@@<<a_api project="eliom" text="Flow"| module Eliom_registration.Flow5 >>|@@colspan="3"@@Portions of HTML pages.|
|=@@class="row"@@<<a_api project="eliom" text="Action"| module Eliom_registration.Action >>|@@colspan="3"@@Actions (server side effects) with or without reloading the page (e.g. login, logout, payment, modification of user information ...)|
|=@@class="row"@@<<a_api project="eliom" text="Files"| module Eliom_registration.File >>|@@colspan="3"@@Serve files from the server hard drive|
|=@@class="row"@@<<a_api project="eliom" text="Ocaml"| module Eliom_registration.Ocaml >>|@@colspan="3"@@OCaml value to be sent to a client side OCaml program (this kind of services is used as low level interface for server functions ­ see below)|
|=@@class="row"@@<<a_api project="eliom" text="String"| module Eliom_registration.String >>|@@colspan="3"@@Any OCaml string (array of byte)|
|=@@class="row"@@<<a_api project="eliom" text="Redirection"| module Eliom_registration.Redirection >>|@@colspan="3"@@Redirection to another service|
|=@@class="row"@@<<a_api project="eliom" text="Any"| module Eliom_registration.Any >>|@@colspan="3"@@To be used to make the service chose what it sends. Call function send from the corresponding module to choose the output.|
|=@@class="row"@@<<a_api project="eliom" text="Customize"| module Eliom_registration.Customize >>|@@colspan="3"@@Defining your own registration module (functor)|
>>

===Parameters===

Module <<a_api project="eliom"| module Eliom_parameter>>
is used to describe the type of service parameters.

Examples:
<<code language="ocaml"|
Eliom_parameter.(int "i" ** (string "s" ** bool "b"))
   (* /path?i=42&s=toto&b=on *)

Eliom_parameter.(int "i" ** opt (string "s"))
   (* An integer named i, and an optional string named s *)

Eliom_parameter.(int "i" ** any)
   (* An integer named i, and any other parameters, as an association list
      of type (string * string) list *)

Eliom_parameter.(set string "s")
   (* /path?s=toto&s=titi&s=bobo *)

Eliom_parameter.(list "l" (int "i"))
   (* /path?l[0]=11&l[1]=2&l[2]=42 *)

Eliom_parameter.(suffix (int "year" ** int "month"))
   (* /path/2012/09 *)

Eliom_parameter.(suffix_prod (int "year" ** int "month") (int "a"))
   (* /path/2012/09?a=4 *)

>>

===POST services===

To define a service with POST parameters, just change the {{{~meth}}} parameter.
For example the following example takes the same GET parameters as the service
above, plus one POST parameter of type string, named "mypostparam".
<<code language="ocaml" class="server"|
    ~meth:(Eliom_service.Post (Eliom_parameter.((string "myparam" ** int "i"),
                                                (string "mypostparam"))))
>>

===Pathless services===

Pathless services are not identified by the path in URL,
but by a name given as parameter. This name can be specified manually
using the {{{~name}}} optional parameter, otherwise, a random name is
generated automatically.
Use this to make a behaviour available from all pages
(for example: log-in or log-out actions, add something in a shopping basket ...)

<<code language="ocaml" class="server"|
let pathless_service =
  Eliom_service.create
    ~name:"pathless_example"
    ~path:Eliom_service.No_path
    ~meth:(Eliom_service.Get (Eliom_parameter.(int "i")))
    ()
>>

More information
<<a_manual project="eliom" chapter="server-services" fragment="pathless"|in the manual>>.

===External services===
Use <<a_api project="eliom"| val Eliom_service.extern >> to create
links or forms towards external Web sites as if they were Eliom services.

===Predefined services===
Use <<a_api project="eliom"| val Eliom_service.static_dir >> to create links towards static files.

Use <<a_api project="eliom"| val Eliom_service.reload_action >> and its variants to create links or forms towards the current URL (reload the page).

<<a_manual project="eliom" chapter="server-services" |Full documentation about services>>, [[interaction|a tutorial about traditional service based Web programming]], API documentation of modules <<a_api project="eliom" subproject="server" | module Eliom_service>> and <<a_api project="eliom" subproject="server" | module Eliom_registration>>.
>>

<<section class="docblock" |
<<header |==Forms and links==>>

Functions {{{Eliom_content.Html.F.a}}} and {{{D.a}}}
create typed links to services with their parameters.
For example, if {{{home_service}}} expects no parameter
and {{{other_service}}} expects a string and an optional int:
<<code language="ocaml"|
Eliom_content.Html.D.a ~service:home_service [txt "Home"] ()
Eliom_content.Html.D.a ~service:other_service [txt "Other"] ("hello", Some 4)
>>

Modules {{{Eliom_content.Html.F.Raw}}} and {{{D.Raw}}} define the links
and form elements with the usual typed interface from TyXML.
Use this for example if you have a client side progra and
want to manipulate the form contents from client side functions
(for example do a server function call with the form element content).

In contrast, modules {{{Eliom_content.Html.F}}} and {{{D}}} define a typed interface
for form elements. Use this for links (see above), or if you program traditional
server-side Web interaction. This will statically check that your forms
match the services. Example:

<<code language="ocaml"|
open Eliom_content.Html.D
>>

<<code language="ocaml"|
post_form
 ~service:connection_service
   (fun (name, password) ->
     [fieldset
       [label ~a:[a_for name] [txt "Name: "];
        string_input ~input_type:`Text ~name:name ();
        br ();
        string_input
          ~a:[a_placeholder "Password"]
          ~input_type:`Password
          ~name:password
          ();
        br ();
        string_input ~input_type:`Submit ~value:"Connect" ()
      ]]) ()

>>

>>
<<section class="docblock" |
<<header |==Js_of_ocaml==>>

//Js_of_ocaml// is a compiler of OCaml bytecode to JavaScript,
allowing to run Ocaml programs in a Web browser.
Its key features are the following:
* The whole language, and most of the standard library are supported.
* The compiler is easy to install: it depends only on Findlib and Lwt.
* The generated code which is independant of Eliom and Ocsigen Server. You can use it with any Web server.
* You can use a standard installation of OCaml to compile your programs. In particular, you do not have to recompile a library to use it with Js_of_ocaml. You just have to link your program with a specific library to interface with the browser API.

Interaction with Javascript can be done:
* either with untyped function calls (module {{{Js.Unsafe}}}),
* or you can generate an interface just by writing an annotated {{{.mli}}}
using [[https://github.com/LexiFi/gen_js_api|Gen_js_api]],
* or you use a syntax extension to generate typed calls, using a
{{{.mli}}} file describing Javascript objects
with OCaml class types as phantom types.

The latter is used for the default Javascript library. Here is how it works:

|{{{obj##.m : u}}}|access a JS property, when {{{obj : <m : u prop> Js.t}}}|
|{{{obj##.m := e : unit}}}|change a JS property, when {{{obj : <m : u prop> Js.t}}} and {{{e:u}}}|
|{{{obj##m e_1 ... e_n : u}}}|call a JS method, when {{{obj : <m : t_1 -> ... -> t_n -> u meth; ..> Js.t}}} and {{{e_i : t_i}}}|
|{{{new%js constr e1 ... en : u Js.t}}}|create a JS object, when {{{constr : (t_1 -> ... -> t_n -> u Js.t) Js.constr}}} and {{{e_i : t_i}}}|

>>

<<section class="docblock" |
<<header |==Eliom: client-server apps==>>

Eliom can transform OCaml into a multi-tier language, allowing one to
implement (both the server and client parts of) a distributed application
entirely in OCaml, as a single program.
This simplifies a lot the communication between server and client.

Pages can be generated either on the server or the client.
The first HTTP request usually returns a server-side generated HTML page
(thus indexable by seach engine). But subsequent page generations are done
by the client, for performance reasons.
In a mobile app, all pages are usually generated on the client.

Client side features can be mixed with traditional Web interaction
(links, forms, bookmarks, back button ...)
One of the key feature of Eliom is that it allows
one to mix commonplace Web interactions (URLs, forms, links,
bookmarks, back button) with dynamic client side features. In
particular, the client-side program **does not stop** when the user
clicks a link, sends a form, or presses the back button--yet the user
still can save bookmarks on pages!  This opens up a wide field of new
possibilities.

===Sections===
|{{{ let%shared ... = ... }}}|Code to be included in both the client and server apps|
|{{{ let%client ... = ... }}}|Code to be included in client app only|
|{{{ let%server ... = ... }}}|Code to be included in server app only|

Same for {{{ module%shared }}}, {{{ open%shared }}}, {{{ type%shared }}} etc.

===Client values===
Client values can be declared within server or shared code as
   {{{ [%client[ (<value> : <type>) ] }}}.
The type annotation is almost always required.

If such section is reached while generating a page on server side,
the client-side code will be executed once the page is displayed.
If such section is reached while generating a page on client side,
the client-side code will be executed immediately.

The tutorial [[tutowidgets|Client-Server Widgets]]
shows how client values can be manipulated
on client side.

===Injections===

Server side variables can be accessed (injected) in client code by prefixing
them with {{{~%}}} as in this example:
<<code language="ocaml" class="server"|
let%server ... =
  ... let x = ... in [%client[ ... ~%x ... ]] ...
}}
>>
The value will automatically be sent with the page by Eliom.

===Example===
This section shows a typical example of client-server code: call a function
when user clicks on a page element.

<<code language="ocaml" class="client"|
open%client Js_of_ocaml
open%client Js_of_ocaml_lwt
open%client Eliom_content.Html>>
<<code language="ocaml" class="shared"|open%shared Eliom_content.Html.F>>
<<code language="ocaml" class="server"|let%server theservice = Eliom_service.create ~path:["ex"] ~meth:(Eliom_service.Get Eliom_parameter.unit) ()>>
<<code language="ocaml" class="client"|let%client theservice = ~%theservice>>
<<code language="ocaml" class="shared"|

let%shared () =
  My_app.register ~service:theservice (fun s () ->
      let aa = string_of_int (Random.int 1000) in
      let _ = [%client (print_endline ~%aa : unit)] in (* print in browser console *)
      let b = Eliom_content.Html.D.button [txt aa] in
      let _ =
        (* binding clicks on button (see browser events below) *)
        [%client
          (Lwt.async (fun () ->
               Lwt_js_events.clicks (To_dom.of_element ~%b) (fun _ _ ->
                   Dom_html.window##alert (Js.string (~%aa));
                   Lwt.return_unit))
            : unit)]
      in
      Lwt.return (html (head (title (txt "Example")) []) (body [h1 [txt aa]; b])))
>>

Service handlers and service registration
are usually written in shared sections to enable
page generation on both sides.

===Calling server side functions from the client===

Eliom makes it possible to call server side OCaml functions from your
client-side program. You must export these functions explicitely,
and declare the type of their parameters. Example:

<<code language="ocaml" class="server"|
let%server g i = Lwt.return (string_of_int (i + Random.int 1000))
>>
<<code language="ocaml" class="client"|let%client g =
  ~%(Eliom_client.server_function ~name:"g" [%json: int] g)
>>

Syntax {{{[%json: t]}}} corresponds to the serialisation functions of type {{{t}}}
from JSON. They are generated automatically by
[[https://github.com/ocsigen/deriving|Deriving]], as long as it knows
a deriver for each subtype. To create a deriver for your own types
just append {{{[@@deriving json]}}} after your type declaration. Example:

<<code language="ocaml" class="shared"|
type%shared t = A | B
[@@deriving json]
>>

<<a_manual project="js_of_ocaml" page="ppx-deriving"|More documentation on the JSON deriver>>.
>>


<<section class="docblock" |
<<header |==Sessions==>>

Session data is saved on server side in //Eliom references//.

The following Eliom reference will count the number of visits of a user on a page:

<<code language="ocaml" class="server"|
let%server count_ref =
  Eliom_reference.eref ~scope:Eliom_common.session 0 (* default value for everyone *)
>>

And somewhere in your service handler, increment the counter:
<<code language="ocaml" class="server"|
let%lwt count = Eliom_reference.get count_ref in
Eliom_reference.set count_ref (count + 1);
Lwt.return ()
>>

An Eliom reference can be persistant (value saved on hard drive) or volatile (in memory).

===Scopes===
Sessions are relative to a browser, and implemented using browser cookies.
But Eliom allows to create Eliom references with other //scopes// than session:

|<<a_api project="eliom" text="global_scope"| val Eliom_common.global_scope>>|Global value for all the Web server|
|<<a_api project="eliom" text="site_scope"| val Eliom_common.site_scope>>|Global value for the Eliom app in that subsite of the Web site|
|<<a_api project="eliom" text="default_group_scope"| val Eliom_common.default_group_scope>>|Value for a group of sessions. For example Ocsigen Start defines a group of session for each user, making it possible to save server side data for all sessions of a user.|
|<<a_api project="eliom" text="default_session_scope"| val Eliom_common.default_session_scope>>|The usual session data, based on browser cookies|
|<<a_api project="eliom" text="default_process_scope"| val Eliom_common.default_process_scope>>|Server side data for a given client-side process (a tab of the browser or a mobile app).|

Applications based on Ocsigen Start use these scopes for user management.
Session or client process data are discarded when a user logs in or out.
But Ocsigen Start also defines scopes
<<a_api project="ocsigen-start" | val Os_session.user_indep_session_scope>>
and
<<a_api project="ocsigen-start" | val Os_session.user_indep_process_scope>>
which remain even if user logs in or out.
>>

When session group is not set (for example the user is not connected),
you can still use scope session group: in that case, the group contains only
one session.

<<section class="docblock" |
<<header |==Browser events==>>

Attributes like {{{a_onclick}}} in module {{{Eliom_content.Html.D}}} or {{{F}}}
take a client side function as parameter:

<<code language="ocaml" class="shared"|
div ~a:[a_onclick [%client fun ev -> ... ]] [ ... ]
>>

Module {{{Lwt_js_events}}} of Js_of_ocaml defines a way to bind browser events
using Lwt promises.

For example,
the following code will wait for a click on element {{{d}}} before continuing:
<<code language="ocaml" class="client"|
let%lwt ev = Lwt_js_events.click (Eliom_content.Html.To_dom.of_element ~%d) in
...
>>

Functions like {{{Lwt_js_events.clicks}}} or {{{Lwt_js_events.mousedowns}}}
(ending with "s")
will call the function given as second parameter
**for each** {{{click}}} or {{{mousedown}}} events
on their first parameter.

For example, the following code (inspired from [[graffiti|this tutorial]])
will wait for all {{{mousedown}}} events on the canvas,
then for each {{{mousemove}}} event on the document,
it will call function {{{f}}}, until {{{mouseup}}} is triggered.
(See <<a_api project="lwt"| val Lwt.pick>>)
<<code language="ocaml" class="client"|
let open Lwt_js_events in
Lwt.async (mousedowns
            (Eliom_content.Html.To_dom.of_element ~%canvas)
            (fun ev _ ->
               Lwt.pick [mousemoves Dom_html.document f;
	                 mouseup Dom_html.document]))
>>
>>

<<section class="docblock" |
<<header |==Ocsigen Toolkit==>>

Ocsigen Toolkit defines several widgets that can be generated either
on server or clide sides. Have look at
[[wiki("ocsigen-start"):demo/|Ocsigen Start's demo app]]
(or the [[https://play.google.com/store/apps/details?id=com.osdemo.mobile|corresponding Android app]]) to see them in action: carousel, drawer menu, date or time picker, color picker, etc.

>>

<<section class="docblock" |
<<header |==Ocsigen Start==>>

//Ocsigen-start// is a library and a template of Eliom application,
with many common features like
user registration, login box, notification system, etc.

It also provides a demo of many features presented in this page.
A [[wiki("ocsigen-start"):demo/|live version]] is accessible online.
Read [[start|this page]] to create your first Ocsigen Start
app and take time to study the code of each example.
>>

<<section class="docblock" |
<<header |==Database access==>>

You can use your favourite database library with Ocsigen.
Ocsigen Start's template is using
[[https://github.com/darioteixeira/pgocaml|PG'OCaml]]
(typed queries for Postgresql using a PPX syntax extension).

Here is an example, taken from Ocsigen Start's demo:
<<code language="ocaml" class="server"|
let get () =
  full_transaction_block (fun dbh ->
    [%pgsql dbh "SELECT lastname FROM ocsigen_start.users"])
>>

>>

<<section class="docblock" |
<<header |==Server to client communication==>>

Modules
<<a_api project="eliom"| module Eliom_notif>>
and
<<a_api project="ocsigen-start"| module Os_notif>>
define the simplest interface to enable server to client communication
(the second one being aware of Ocsigen Start users).

<<div class="focused"|
===How it works===
Say you want to receive the messages for one or more chat rooms.
First, define your notification module:
<<code language="ocaml" class="server"|
module%server Notif = Os_notif.Make_Simple (struct
  type key = int64 (* the chat room ids *)
  type notification = string (* the type of messages *)
end)
>>

If you want to be notified when there a new message in a chat room, call function
{{{Notif.listen}}} (server side) on the chat room id.

If you want to send a message in a chat room, call function
{{{Notif.notify}}} (server side) with the chat room id and the message as parameter.

On client side, {{{~%(Notif.client_ev ())}}} is a React event of type
{{{(key, notif) React.E.t}}}. Use it to receive the messages.
>>

Eliom has other communication modules:
* <<a_api project="eliom"| module Eliom_bus>> defines a communication bus,
that you can use to share information with other client processes
(see an example [[application|here]]).
* <<a_api project="eliom"| module Eliom_react>> defines client-server React events.
* <<a_api project="eliom"| module Eliom_comet>> is lower level interface for
server to client communication.

>>

<<section class="docblock" |
<<header |==Internationalisation==>>

[[https://github.com/besport/ocsigen-i18n|Ocsigen i18n]]
is an internationalisation library for your OCaml programs.

Create a .tsv file with on each line a key and the text in several languages:

{{{
welcome_message Welcome everybody!        Bienvenue à tous !      Benvenuti a tutti !
}}}

and Ocsigen i18n will automatically generate functions like this one:
<<code language="ocaml" class="shared"|
let%shared welcome_message ?lang () () =
  match lang with
  | En -> [txt "Welcome everybody!"]
  | Fr -> [txt "Bienvenue à tous !"]
  | It -> [txt "Benvenuti a tutti !"]
>>

Ocsigen i18n also define a syntax extension to use these functions:
<<code language="ocaml" class="shared"|
  Eliom_content.Html.F.h1 [%i18n welcome_message]
>>

Ocsigen i18n offers many other features:
* Text can be inserted as a TyXML node (as in the example above) or as a string
* Text can be parametrizable, or contain holes
* .tsv file can be splitted into several modules

Have a look at the
[[https://github.com/besport/ocsigen-i18n|README file]]
to see the full documentation,
and see examples in Ocsigen Start's template.

>>

<<section class="docblock" |
<<header |==Reactive programming==>>

Eliom allows to insert //reactive nodes// in pages, that is, nodes which are automatically
updated when the values on which they depend change.

This is based on the [[https://erratique.ch/software/react|React]] library by Daniel Bünzli,
which implements //Functional Reactive Programming//.

<<div class="focused"|
===Functional Reactive Programming principle===

Function {{{React.S.create}}} creates a signal and a function to chage its value:
<<code language="ocaml" class="client"|
let%client mysignal, set_mysignal = React.S.create 0
>>

Functions like {{{React.S.map}}} or {{{React.S.l2}}} create new signals
from one (resp. two) input signals.
They are updated automatically when their input signals change.
For example, we can can define the same value as a string and as TyXML node:
<<code language="ocaml" class="client"|
let%client s_string = React.S.map string_of_int mysignal
let%client s_p = React.S.map (fun v -> p [txt v]) s_string
>>

>>

===Reactive nodes===

Insert a (client side) reactive node in a page using function
<<a_api project="eliom"| val Eliom_content.Html.R.node >>:

<<code language="ocaml" class="client"|
let%client f () =
  let open Eliom_content.Html in
  F.div [ R.node s_p ]
>>

===Reactive node content===

Module
<<a_api project="eliom"| val Eliom_content.Html.R >>
also defines all TyXML nodes TyXML,
which take reactive content as parameter.

For example {{{Eliom_content.Html.R.txt}}} take
a value of type {{{string React.S.t}}} as parameter (string signal).

Instead of taking a list signal as parameter, functions like
{{{div}}} or {{{p}}} of module {{{Eliom_content.Html.R}}}
take a parameter of type
[[https://github.com/ocsigen/reactiveData|Eliom_content.Html.F.elt ReactiveData.Rlist.t]].
This enables incremental update of the content
(usually, appending an element at the end of the list,
without having to redraw the whole list).
See an example with {{{ReactiveData}}} in [[tutoreact|this tutorial]].

Node attributes can also be reactive.

===Client-server reactive programming===

Reactive nodes can be created in server or shared sections.
To do that, use module
<<a_api project="eliom"| module Eliom_shared.React >>
instead of the usual {{{React}}} module.
On client side, this module behaves like {{{React}}}.
But when executed on server side, it will generate a non reactive values,
that will automatically become reactive on the client.

Full example:
<<code language="ocaml" class="server"|let%server theservice = Eliom_service.create ~path:["ex"] ~meth:(Eliom_service.Get Eliom_parameter.unit) ()>>
<<code language="ocaml" class="client"|let%client theservice = ~%theservice>>
<<code language="ocaml" class="client"|
[%%client open Js_of_ocaml_lwt]>>
<<code language="ocaml" class="shared"|[%%shared open Eliom_content.Html.F]

let%shared () =
  My_app.register ~service:theservice (fun () () ->
      let monsignal, set_signal = Eliom_shared.React.S.create 0 in
      let s_string =
        Eliom_shared.React.S.map [%shared string_of_int] monsignal
      in
      let _ =
        [%client
          (let rec aux () =
             let%lwt () = Lwt_js.sleep 1.0 in
             ~%set_signal (Random.int 100);
             aux ()
           in
           Lwt.async aux
            : unit)]
      in
      Lwt.return
        (html
           (head (title (txt s)) [])
           (body [h1 [txt s]; p [Eliom_content.Html.R.txt s_string]])))
>>

Function {{{Eliom_shared.React.S.map}}} (and {{{Eliom_shared.React.S.l2}}}, etc)
takes a //shared function// as parameter (syntax {{{@@class="shared"@@[%shared f]}}}).
This can be seen as a couple containing both the server a client side implementation
of the function.


>>

<<section class="docblock" |
<<header |==Mobile apps==>>
Applications can run on any Web browser or mobile device (iOS, Android, ...),
thus eliminating the need for one custom version per platform.

Ocsigen Start's template comes with a Makefile which will automatically
download the required NPM modules for Cordova and build you Android or iOS
apps.
Read the [[https://github.com/ocsigen/ocsigen-start/blob/master/template.distillery/README.md|README]] file
to learn how to do that.

Download
[[https://play.google.com/store/apps/details?id=com.osdemo.mobile|Ocsigen Start's demo app]]
from Google Play store to see an example.
[[https://www.besport.com/news|Be Sport]] apps are also generated like this (available in
[[https://play.google.com/store/apps/details?id=com.besport.www.mobile|Google Play Store]]
and [[https://apps.apple.com/fr/app/be-sport/id1104216922|Apple app store]]).
>>

<<section class="docblock" |
<<header |==Ocsigen Server==>>

//Ocsigen Server// is a full featured Web server written in modular way.
It implements most features of the HTTP protocol, and has a powerful
extension mechanism that make easy to plug your own OCaml modules
for generating pages. Many extensions are already written:
;<<a_manual project="ocsigenserver" chapter="staticmod"|Staticmod>>
:    to serve static files.
;[[wiki("eliom"):|Eliom]]
:    to create reliable client/server Web applications
     or Web sites in OCaml using advanced high level concepts.
;<<a_manual project="ocsigenserver" chapter="extendconfiguration"|Extendconfiguration>>
:    allows for more options in the configuration file.
;<<a_manual project="ocsigenserver" chapter="accesscontrol"|Accesscontrol>>
:    allows to restrict the access to the sites from the config file (to request coming from a subnet, containing some headers, etc.).
;<<a_manual project="ocsigenserver" chapter="authbasic"|Authbasic>>
:    allows to restrict the access to the sites from the config file using Basic HTTP Authentication.
;<<a_manual project="ocsigenserver" chapter="cgimod"|CGImod>>
:    serves CGI scripts. It may also be used to serve PHP through CGI.
;<<a_manual project="ocsigenserver" chapter="deflatemod"|Deflatemod>>
:    used to compress data before sending to the client.
;<<a_manual project="ocsigenserver" chapter="redirectmod"|Redirectmod>>
:    sets redirections towards other Web sites from the configuration file.
;<<a_manual project="ocsigenserver" chapter="revproxy"|Revproxy>>
:    a reverse proxy for Ocsigen Server.
      It allows to ask another server to handle the request.
;<<a_manual project="ocsigenserver" chapter="rewritemod"|Rewritemod>>
:    changes in incoming requests before sending them to other extensions.
;<<a_manual project="ocsigenserver" chapter="outputfilter"|Outputfilter>>
:    rewrites some parts of the output before sending it to the client.
;<<a_manual project="ocsigenserver" chapter="userconf"|Userconf>>
:    allows users to have their own configuration files.
;<<a_manual project="ocsigenserver" chapter="comet"|Comet>>
:    facilitates server to client communications.

Ocsigen Server has a <<a_manual project="ocsigenserver"
chapter="config"|sophisticated configuration>> file mechanism allowing
complex configurations of sites.

>>
